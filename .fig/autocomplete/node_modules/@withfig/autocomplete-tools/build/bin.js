#!/usr/bin/env node
"use strict";var Ee=Object.create;var H=Object.defineProperty;var Ie=Object.getOwnPropertyDescriptor;var Pe=Object.getOwnPropertyNames;var Oe=Object.getPrototypeOf,Te=Object.prototype.hasOwnProperty;var $e=(e,o,t,n)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of Pe(o))!Te.call(e,r)&&r!==t&&H(e,r,{get:()=>o[r],enumerable:!(n=Ie(o,r))||n.enumerable});return e};var s=(e,o,t)=>(t=e!=null?Ee(Oe(e)):{},$e(o||!e||!e.__esModule?H(t,"default",{value:e,enumerable:!0}):t,e));var xe=require("commander");var E=s(require("fs")),I=require("commander"),P=require("@fig/autocomplete-merge");async function Le(e,o,t){let{ignoreProps:n=[],ignoreCommandProps:r=[],ignoreOptionProps:i=[],ignoreArgProps:f=[],newFile:w,preset:l}=t,x=await(0,P.merge)(E.default.readFileSync(e,{encoding:"utf8"}),E.default.readFileSync(o,{encoding:"utf8"}),{preset:l,ignore:{commonProps:n,commandProps:r,optionProps:i,argProps:f}});E.default.writeFileSync(w||e,x)}var R=new I.Command("merge").arguments("<oldspec> <newspec>").description("deep merge new spec into old spec").option("-n, --new-file <path>","Create a new spec file instead of updating the old one").option("-i, --ignore-props <props>","The props that should always be overridden.",e=>e.split(",")).option("--ignore-command-props <props>","The command props that should always be overridden.",e=>e.split(",")).option("--ignore-option-props <props>","The option props that should always be overridden.",e=>e.split(",")).option("--ignore-arg-props <props>","The arg props that should always be overridden.",e=>e.split(",")),Me=new I.Option("-p, --preset <name>","Use a preset").choices(Object.keys(P.presets));R.addOption(Me);R.action(Le);var K=R;var b=s(require("os")),m=s(require("fs")),y=s(require("path")),a=s(require("chalk")),se=require("commander");var ee=require("esbuild"),oe=require("@esbuild-plugins/node-modules-polyfill"),te=s(require("chokidar")),ne=require("commander"),re=s(require("fast-glob")),N=s(require("node:fs/promises")),C=s(require("node:path"));var Z=s(require("chalk"));var S=class{static log(o,t="blue"){console.log(Z.default[t](o))}};var X=require("node:child_process");function v(e,o){try{return(0,X.execFileSync)(e,o),!0}catch{return!1}}var _;function De(){return _===void 0&&(_=v("fig",["--version"])),_}var V;function je(){return V===void 0&&(V=v("cw",["--version"])),V}var k;function z(){return k===void 0&&(k=v("q",["--version"])),k}function h(e,o){z()?v("q",["settings",e,JSON.stringify(o)]):je()?v("cw",["settings",e,JSON.stringify(o)]):De()&&v("fig",["settings",e,JSON.stringify(o)])}var Re="src",Y="build";function _e(){h("autocomplete.developerModeNPMInvalidateCache",!0)}async function Ve(e,o){let t=o.map(C.default.parse),n=t.filter(({base:i})=>i==="index.ts").map(({dir:i})=>i.replace(/^src\//,""));n.sort();let r=t.filter(({base:i,ext:f})=>i!=="index.ts"&&f===".ts").map(i=>`${i.dir}/${i.name}`.replace(/^src\//,"")).concat(n);r.sort(),await N.default.mkdir(e,{recursive:!0}),Promise.all([await N.default.writeFile(C.default.join(e,"index.js"),`var e=${JSON.stringify(r)},diffVersionedCompletions=${JSON.stringify(n)};export{e as default,diffVersionedCompletions};`),N.default.writeFile(C.default.join(e,"index.json"),JSON.stringify({completions:r,diffVersionedCompletions:n})),N.default.writeFile(C.default.join(e,"index.d.ts"),`declare const completions: string[]
declare const diffVersionedCompletions: string[]
export { completions as default, diffVersionedCompletions }
  `)])}async function Q(e,o,t){let n=e.length===1?e[0]:`${e.length} specs`;await Promise.all([(0,ee.build)({entryPoints:e,outdir:t??Y,bundle:!0,outbase:"src",format:"esm",minify:!0,plugins:[(0,oe.NodeModulesPolyfillPlugin)()],...o&&{sourcemap:"inline"}}).catch(r=>S.log(`Error building ${n}: ${r.message}`,"red")),Ve(t??Y,e)]),S.log(`Built ${n}`),_e()}async function G({watch:e,outdir:o}){let t=`${Re}/**/*.ts`,n=await(0,re.default)(t);if(await Q(n,void 0,o),e){let r=te.default.watch(t,{ignoreInitial:!0});r.on("change",i=>Q([i],!0,o)),r.on("add",i=>Q([i],!0,o))}}var ke=new ne.Command("compile").description("compile specs in the current directory").option("-w, --watch","Watch files and re-compile on change").option("-o, --outdir <dir>","Output directory").action(G),ie=ke;var F=y.default.join(b.default.homedir(),".fig","logs","specs.log");function ze(){console.log(`

Fig dev mode disabled
`),h("autocomplete.developerMode",!1),h("autocomplete.developerModeNPM",!1),h("autocomplete.developerModeNPMInvalidateCache",!0),process.exit(0)}function U(){ze(),m.default.unwatchFile(F)}async function Qe({outdir:e}){if(console.clear(),b.default.type()==="Darwin"){let t="/Applications/Fig.app",n=y.default.join(b.default.homedir(),"Applications/Fig.app"),r="/Applications/Amazon Q.app",i=y.default.join(b.default.homedir(),"Applications/Amazon Q.app");!m.default.existsSync(t)&&!m.default.existsSync(n)&&!m.default.existsSync(r)&&!m.default.existsSync(i)&&console.log(`
******

`,a.default.bold(a.default.yellow(" WARNING: Amazon Q for command line app is not installed")),`

`,a.default.bold(a.default.cyan(" Download Amazon Q for command line at:")),`
 https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/command-line-getting-started-installing.html`,`

******
`)}else b.default.type()==="Linux"?console.log(`
******

`,a.default.bold(a.default.yellow(" WARNING: Amazon Q for command line on Linux is not supported yet")),`

`):z()||console.log(`
******

`,a.default.bold(a.default.yellow(" WARNING: Amazon Q for command line is not installed")),`

`,a.default.bold(a.default.cyan(" Download Amazon Q for command line at:")),`
 https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/command-line-getting-started-installing.html`,`

******
`);console.log(`Welcome to ${a.default.magenta("Fig Dev Mode")}!

`,`All completions will be loaded from ${a.default.bold(`${process.cwd()}/${e??"build"}`)}. (Note: other completions won't work while in dev mode).

`,`1. Edit your spec(s) in the ${a.default.bold("src/")} directory.
`,`2. Test changes ${a.default.bold("instantly")} on save in your terminal.
`,`3. Exit developer mode with ${a.default.bold("ctrl + c")}.

`,`${a.default.bold("Other Notes:")}
`,`- Generators run on every keystroke
`),process.addListener("SIGTERM",U),process.addListener("SIGINT",U),process.addListener("SIGQUIT",U),h("autocomplete.developerModeNPM",!0),h("autocomplete.devCompletionsFolder",y.default.join(process.cwd(),e??"build").replace(/(\s)/g,"\\$1")),m.default.existsSync(y.default.dirname(F))||m.default.mkdirSync(y.default.dirname(F),{recursive:!0}),m.default.writeFileSync(F,"",{encoding:"utf8"});let o="";m.default.watch(F,t=>{if(t==="change"){let n=m.default.readFileSync(F,{encoding:"utf8"}).trim(),r=o?n.split(`
`).slice(o.split(`
`).length).join(`
`):n;console.log(a.default.yellow(r)),o=n}}),await G({watch:!0,outdir:e})}var Ge=new se.Command("dev").description("watch for changes and compile specs").option("-o, --outdir <dir>","Output directory").action(Qe),ae=Ge;var J=require("create-completion-spec"),ce=require("commander"),pe=s(require("readline")),le=s(require("path")),de=s(require("chalk")),Ue=new ce.Command("create-spec").description("create spec with given name").arguments("[name]").action(e=>{let o=le.default.resolve(process.cwd(),"src");if(e)(0,J.createCompletionSpec)(e,o);else{let t=pe.default.createInterface({input:process.stdin,output:process.stdout});t.question("What's the name of the CLI tool you want to create an autocomplete spec for: ",async n=>{try{(0,J.createCompletionSpec)(n,o)}catch(r){console.log(de.default.red(r.message)),process.exit(1)}finally{t.close()}})}}),me=Ue;var fe=require("create-completion-spec"),ue=require("commander"),Je=new ue.Command("init").description("initialize fig custom spec boilerplate in current directory").action(fe.createBoilerplateFolder),ge=Je;var A=require("commander"),O=s(require("semver")),T=require("@fig/autocomplete-helpers"),we=require("module-from-string"),he=s(require("prettier")),p=s(require("fs")),c=s(require("typescript")),ye=require("esbuild"),d=s(require("path")),Se=(e,o)=>{p.default.existsSync(o)||p.default.mkdirSync(o,{recursive:!0});for(let t of p.default.readdirSync(e,{withFileTypes:!0}))t.isDirectory()?Se(d.default.resolve(e,t.name),d.default.resolve(o,t.name)):t.isFile()&&p.default.writeFileSync(d.default.resolve(o,t.name),p.default.readFileSync(d.default.resolve(e,t.name)),{encoding:"utf8"})},ve=(e,o)=>c.default.transform(e,[t=>n=>{let r=i=>o(c.default.visitEachChild(i,r,t));return c.default.visitNode(n,r)}]).transformed[0],We=(e,o)=>{let t=[];return ve(e,n=>{let r=o(n);return r!==null&&t.push(r),n}),t},$=e=>he.default.format(Array.isArray(e)?e.join(`
`):e,{parser:"typescript"}),Fe=async e=>{let o=(await(0,ye.build)({entryPoints:[e],bundle:!0,write:!1,sourcemap:!1,loader:{".ts":"ts"},keepNames:!0,target:"esnext",minify:!1,format:"esm"})).outputFiles[0].text;return(0,we.importFromStringSync)(o,{dirname:process.cwd()})},qe=async(e,o)=>{if(!p.default.existsSync(e))return{source:await $([`const completion: Fig.Subcommand = ${JSON.stringify(o,null,4)}
`,`const versions: Fig.VersionDiffMap = {};
`,"export { versions };","export default completion"]),spec:o,versions:{}};let t=await Fe(e);if(!t.versions)throw new Error("Path does not contain versioned spec");return{source:p.default.readFileSync(e).toString(),spec:t.default,versions:t.versions}};async function Be(e,o){let t=p.default.readFileSync(e).toString(),n=!1,r=c.default.createSourceFile(e,t,c.default.ScriptTarget.ES2015,!0),i=ve(r,l=>c.default.isArrayLiteralExpression(l)&&c.default.isVariableDeclaration(l.parent)&&c.default.isIdentifier(l.parent.name)&&l.parent.name.escapedText==="versionFiles"?(n=!0,c.default.factory.updateArrayLiteralExpression(l,[...l.elements,c.default.factory.createStringLiteral(o)])):l);if(!n)throw new Error("Failed to add version to index");let w=c.default.createPrinter({newLine:c.default.NewLineKind.LineFeed}).printNode(c.default.EmitHint.Unspecified,i,r);p.default.writeFileSync(e,await $(w))}var He=e=>e.replace(/[^a-zA-Z0-9_\-/.]/,"");async function W(e,o){let t=He(e),n=d.default.resolve(o.cwd??process.cwd(),e);p.default.mkdirSync(n,{recursive:!0}),p.default.writeFileSync(`${n}/index.ts`,await $([`import { createVersionedSpec } from "@fig/autocomplete-helpers";
`,`const versionFiles = [];
`,`export default createVersionedSpec("${t}", versionFiles);
`].join(`
`)))}async function Ke(e,o,t,n){let r=d.default.resolve(n.cwd??process.cwd(),e);if(n.newPath){let u=d.default.resolve(n.newPath,e);if(p.default.existsSync(r)){let j=d.default.relative(r,u);if(j&&!j.startsWith("..")&&!d.default.isAbsolute(j))throw new Error("'--new-path' must not be a sub-directory of the old spec directory");Se(r,u)}else await W(e,{cwd:n.newPath});r=u}else p.default.existsSync(r)||await W(e,{cwd:n.cwd});let i=O.default.parse(t),f;i===null?f=t:f=n.useMinorBase?`${i.major}.${i.minor}.0`:`${i.major}.0.0`;let w=d.default.resolve(r,`${f}.ts`),l=(await Fe(o)).default,{source:x,spec:Ne,versions:q}=await qe(w,l),L=Object.keys(q).sort(O.default.compare),M=L[L.length-1];if(M&&O.default.compare(t,M)<=0)throw new Error(`Cannot publish version ${t}, later version ${M} already exists`);let Ce=L.map(u=>q[u]).reduce(T.applySpecDiff,Ne),Ae=(0,T.diffSpecs)(Ce,l)??{},D=We(c.default.createSourceFile(w,x,c.default.ScriptTarget.ES2015,!0),u=>c.default.isExportSpecifier(u)&&u.name.escapedText==="versions"?u.parent.parent:null);if(D.length===0)throw new Error("No version export found");let B=D[D.length-1].getStart();p.default.existsSync(w)||Be(d.default.resolve(r,"index.ts"),f),p.default.writeFileSync(w,await $([x.slice(0,B),`
versions["${t}"] = ${JSON.stringify(Ae,null,4)}
`,x.slice(B)]))}async function Ze(e){throw new Error("Unimplemented")}var be=new A.Command("version").addCommand(new A.Command("add-diff").arguments("<specName> <newSpecFilePath> <diffVersion>").description("generate version diff from new spec and add into old spec").option("-n, --new-path <path>","The root folder where the updated spec will be saved. Note: this must NOT include the folder spec name").option("--cwd <path>","Resolve the spec name relative to this directory").option("--use-minor-base","Create a new version file per minor version").action(Ke)).addCommand(new A.Command("init-spec").arguments("<name>").option("--cwd <path>","Generate the spec relative to this directory").description("Generate versioned spec in folder specified by path").action(W)).addCommand(new A.Command("precompute-specs").arguments("<files...>").description("[Unimplemented] Precompute versioned specs before publishing the specs repo (unimplemented)").action(Ze));var g=new xe.Command;g.name("@withfig/autocomplete-tools").description("Dev tools for fig's autocomplete").version("1.0.0");g.addCommand(ge);g.addCommand(me);g.addCommand(ie);g.addCommand(ae);g.addCommand(K);g.addCommand(be);g.parse(process.argv);
